
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Starter Template for Bootstrap</title>

    <!-- Bootstrap core CSS -->
    <link href="dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet"> -->

    <!-- Custom styles for this template -->
    <link href="starter-template.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <!-- <script src="../../assets/js/ie-emulation-modes-warning.js"></script> -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Photo displayer</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#obj">Project Objective</a></li>
            <li><a href="#design">Design and Testing</a></li>
            <li><a href="#result">Result</a></li>
            <li><a href="#conclusion">Conclusion</a></li>
            <li><a href="#future work">Future work</a></li>
            <li><a href="#appendix">Appendix</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">

      <div class="starter-template">
        <h1>Photo displayer</h1>
        <p class="lead">ECE5725 Final Project<br>By Zhuoheng Li(zl764), Xinyun Guo(xg284)</p>
      </div>

      <hr>
      <div class="center-block">
          <iframe width="640" height="360" src="https://www.youtube.com/embed/F7hMKiuZlGA" frameborder="0" allowfullscreen></iframe>
          <h4 style="text-align:center;">Demonstration Video</h4>
      </div>

      <hr id="intro">

      <div style="text-align:center;">
              <h2>Introduction</h2>
              <p style="text-align: left;padding: 0px 30px;font-size:16px;">Our project is a photo displayer with two components: a web application which allows users to upload pictures to the Raspberry Pi; a slideshow application reads photos from the server, displays them on the touch screen, and controlled by six functional touch-screen buttons, including lock the current photo (stop the transition), switch to the previous and next photos, speed up or down the transition time, and quit the program. 
                <br>Just imagine that you can upload a new selfie to the server through the web application, and all your family members can see it on the Raspberry Pi at home. Don’t hesitate, share your photos with your family!
                    </div>

    <hr id='obj'>

      <div class="row">
          <div class="col-md-4" style="text-align:center;">
          <img class="img-rounded" src="pics/application.jpg" alt="Image 1" width="300" height="200">
          <br>Figure 1: Application Panel<br>
          </div>
          <div class="col-md-8" style="font-size:18px;">
          <h2>Project Objective</h2>
          <ul>
              <li>Allow users to upload pictures on the web application to Raspberry Pi</li>
              <li>Raspberry Pi receives photos that users uploaded and stores it in a local database</li>
              <li>Allow users to control the display with six functional touch-screen buttons</li>
          </ul>
          </div>
      </div>

    <hr id='design'>

      <div style="text-align:center;">
              <h2>Design and Testing</h2>
              <p style="text-align: left;padding: 0px 30px;font-size:20px;"> High Level Architecture
                  <p style="text-align: left;padding: 0px 30px; font-size:16px;">
                      The process of our design is shown in the figure below: first, users send photos through the web application; then the Pi acts as a server to receive the uploaded images data; after receive those photos, the Pi will save those photos to the database, which in our case a directory; finally, the slideshow application is able to retrieve photos from the database and display them on touch screen.
                  </p>
    
                    <br>
                    <img class="img-rounded" src="pics/highlevel.png" alt="Block diagram" width="350">
                    <br>Figure 2: High-Lvel Architecture diagram
                    <br><br>
                    <p style="text-align: left;padding: 0px 30px;font-size:20px;"> Web Application
                    <p style="text-align: left;padding: 0px 30px; font-size:16px;">
                        We designed a web application for users to upload images from their laptops. The webpage is designed to have two features: to give a title name of the photo users uploaded, to select the local files from users’ end and upload the photos, as indicated in Figure 3 below.  </p>
                    <img class="img-rounded" src="pics/webpage.png" alt="Block diagram" width="350">  
                    <br>Figure 3: user interface of web application<br>
                    <br>
                    <p style="text-align: left;padding: 0px 30px; font-size:16px;">
                        We chose to use Django to build our web server. After installing Django on the Raspberry Pi, we discussed and figured out the abstract model needed to be used in this project. Then, we wrote the model of the object we want to upload which was a class Image. Inside this model, we defined the fields image_name and ImageField. At last, we defined the target folder we were going to send photos to. 
                        <br><br><p style="text-align: left;padding: 0px 30px;font-size:20px;"> Testing<br>
                          <p style="text-align: left;padding: 0px 30px; font-size:16px;">After programming and building the connection to Pi, we run the server from Pi and access the page with the corresponding address from another laptop. We followed the upload process as indicated in Figure 4 below: select an image file from local, name the file, and then click the submit button. The webpage indicated the image has been successfully uploaded. Then, we checked the Pi and found that image under the specific directory. The test result shown the Pi successfully received the images from the users’ end and stored them at the directory as we defined. The web application functioned as we expected. 

                    <div class="row">
                        <div class="column">
                            <img class="img-rounded" src="pics/upload-1.png" alt="Block diagram" width="350">
                        </div>
                        <div class="column">
                            <img class="img-rounded" src="pics/upload-2.png" alt="Block diagram" width="350">
                        </div>
                        <div class="column">
                            <img class="img-rounded" src="pics/upload-3.png" alt="Block diagram" width="350">
                        </div>
                       
                      </div>  
                      <br>Figure 4: uploading process<br>  
                      <br>  
                      </p>      
                    <p style="text-align: left;padding: 0px 30px;font-size:20px;"> Slideshow Application
                    <p style="text-align: left;padding: 0px 30px; font-size:16px;">
                        We also need a slideshow application to achieve the display functionality on the touch screen. The user interface is mainly two panels as shown in the figure below: a thumbnail panel for user to have an overview of all photos in the directory and choose which one they want to display; a display panel which contains six control buttons for users to control the transition of the display. 
                      </p>  
                      <img class="img-rounded" src="pics/application-ui.png" alt="Block diagram" width="700">  
                      <br>Figure 5: Slideshow application UI<br>
                      <br> <p style="text-align: left;padding: 0px 30px; font-size:16px;">
                          At the beginning of the program, we first need to load all the photos into a list. To do this, we used glob library to read all the valid image files under a default folder. The glob library is a Unix style pathname pattern expansion that will match all the files under the folder with the given types. We only need to use several loops to loop through the folder and get any types we want.<br>
                          <br>To display photos on touch screen, we choose PyGame since it is easy to implement on Pi and has touch functionality which match our objectives for control buttons. We first created a surface in Pygame. Then we created ‘rect’ for all photos from the list of photos we read from the directory and define the coordinates where we want photos to display. By using the flip() function, the photos can be displayed on the screen at the place we want. <br>
                          <br>To split the screen into two panels, we need to set coordinates based on the panel positions we want. We set one sixth of the screen be the thumbnail panel, and the rest be the display panel(main panel). On the thumbnail panel, maximum four thumbnail size (100*100)  photos will be displayed and a scroll down button to preview photos in the directory. On the display panel, the first photo on the list will be displayed once the program starts, and it will automatically switch photos as a slideshow. <br>
                          <br>To achieve the automatic switching function, we wrote a loop to change the index, which corresponds to the photo to display in the list of stored all photos, based on running time. To be specific, we set an interval time, which default is 5 seconds. Once the current photo has been displayed for 5 seconds, the index will plus one, which means the display photo will be switch to the next photo in the photo list. Detailed code can be found in appendix.<br>
                          </p>
                          <div class="center-block">
                              <video width="320" height="240" controls>
                                  <source src="pics/demonstrate.mp4" type="video/mp4"></video>>
                                <h4 style="text-align:center;font-size:16px;">Six Functional Buttons Demonstration Video</h4>
                          </div>
                      
                      <br><p style="text-align: left;padding: 0px 30px; font-size:16px;">Six functional buttons description:</p>
                      <ul>
                       <li style="text-align: left;font-size:16px;">Locking the photo: We designed the function of locking current pictures if the user like this photo and don’t want to switch it away. When the photo is locked, the automatic switching function will be disable, but the other photo functions still works under this mode.</li>
                       <li style="text-align: left;font-size:16px;">Switching to the previous photo: This function is used to switch over to the last photo, it works no matter the current photo is locked or not.</li>
                       <li style="text-align: left;font-size:16px;">Switching to the next photo: This function is used to switch over to the next photo, it works no matter the current photo is locked or not.</li>
                       <li style="text-align: left;font-size:16px;">Speeding up: The interval of switching photos will be decreased by pressing this button, which means the transition speed will be increased. The default switching interval is 5 seconds. The maximum switching speed is 1 second per photo.</li>
                       <li style="text-align: left;font-size:16px;">Slowing down: The interval of switching photos will be increased by pressing this button. The minimum switching speed is 15 seconds per photo.</li>
                       <li style="text-align: left;font-size:16px;">Quit: This button is for quitting the program. After clicking this button, the program will be terminated immediately and return to the desktop.</li>
                      </ul>
                    <br><p style="text-align: left;padding: 0px 30px; font-size:16px;">To design the touch functional buttons, we also need to use PyGame. For instance, to design the touch button to quit the program, we first need to define the position of the icon for that button. Then, we use the event.get() to detect any possible hits on the screen and pygame.mouse.get_pos() to detect the coordinates of the hits. If the hits has been detected within the button position as we defined, the system will run specific function. Therefore, touching ‘quit’ button ends the program and returns to the Linux console screen. Similarly, six functional buttons can be programmed.
                      <br><br><p style="text-align: left;padding: 0px 30px;font-size:20px;"> Testing
                      <br><p style="text-align: left;padding: 0px 30px; font-size:16px;">We tested the preview function that allows the user to preview all the photos loaded onto the queue. If the user taps the picture on the preview panel, that photo will be displayed on the main panel too. When we tested this function, we found out that the thumbnail may disappear if pressed. In addition, clicking the scroll down button, all the photos should move up to the upper box and the new photo would show up at the bottom of the preview panel. However, we noticed that the new photo appears at the top and all the photos didn’t wrap around. To fix that, we changed our algorithm and added an arraylist to store the index of photos to display in the queue. With the help of the arraylist, the photo index can be read and the corresponding photo will flip on the panel. Thus, when the scroll button has been clicked, the arraylist will be updated and the photos will be wrap around as we expected.    
                      <br><br>When testing the time switching buttons, we found an error that wasn’t noticeable. The error happens if the user taps on speed up button too many times, and the console will show an error message ‘integer division or modulo by zero’. This happened because when the speed increased, the interval time will be shortened at the same time. If the user taps on speed up button too many times, the interval time will be very close to zero which give such error message. To fix this, we set a minimum interval time 1 second, which means the maximum speed switching speed is 1 second per photo. 
                      <br><br>After debugging, panels displayed well and all functions performed as we expected. 
                    </p>
                    
                    
                    </p>
      </div>

    <hr id='result'>

      <div style="text-align:center;">
              <h2>Result</h2>
              <p style="text-align: left;padding: 0px 30px;font-size:16px;">We were able to successfully accomplish all of the outlined objectives in our project description. Our web application is able to upload photos from users’ end to the Raspberry Pi and the Pi can successfully store those uploaded photos to a specific path as we defined. 
                  The slideshow desktop application also works as we expected. Once the user clicks on the shortcut icon on the desktop, the application will start. The thumbnail panel and display panel performs well and all six control buttons function as we designed.
                  <p style="text-align: left;padding: 0px 30px;font-size:16px;">    
                  However, during the design process, we have encountered some problems with the implement of Django. The biggest challenge is to establish a connection between Pi and web applications. After we investigated the Django documentation and tried several tutorials, we were able to solve the problem and accomplish the goals. 
                  
              </div>


    <hr id='conclusion'>

    <div style="text-align:center;">
            <h2>Conclusion</h2>
            <p style="text-align: left;padding: 0px 30px;font-size:16px;">Overall, we achieved the project features we designed and finished the project within 4 weeks. We learned about how Django works and how it can be integrated with Raspberry Pi. We found it as a useful tool to establish a web application with available templates packages and also easy to implement on Pi. In the process, we also enhanced our PyGame programming, including to achieve split-screen mode.   </p>
    </div>            
    <hr id='future work'>

    <div style="text-align:center;">
            <h2>Future Work</h2>
            <p style="text-align: left;padding: 0px 30px;font-size:16px;">Given more time to work on this project, we would add more features and embellish the user interface of our web application and Pi application panel. Also, more features can be added, including adding categories to classify pictures, filtering photos in specific categories to display, adding the newly uploaded photos to the queue automatically.
            </div>

  <hr>

    <div class="row" style="text-align:center;">
          <h2>Work Distribution</h2>
          <div style="text-align:center;">
              <img class="img-rounded" src="pics/group.jpg" alt="Generic placeholder image" style="width:30%;">
              <h4>Project group picture</h4>
          </div>
          <div class="col-md-6" style="font-size:16px">
              <h3>Zhuoheng Li</h3>
              <p class="lead">zl764@cornell.edu</p>
              Designed the web application with Django and<br> slideshow application with PyGame
          </div>
          <div class="col-md-6" style="font-size:16px">
              <h3>Xinyun Guo</h3>
              <p class="lead">xg284@cornell.edu</p>
              Designed the web application with Django and<br> slideshow application with PyGame
          </div>
      </div>

    <hr>
      <div style="font-size:18px">
          <h2>Parts List</h2>
          <ul>
              <li>Raspberry Pi $35.00</li>
              <li>Raspberry Pi 7" Touch Screen Display $60.00</li>
          </ul>
          <h3>Total: $95</h3>
      </div>
      <hr>
      <div style="font-size:18px">
          <h2>References</h2>
          <a href="https://docs.djangoproject.com/en/3.0/">Django Documentation</a><br>
          <a href="https://www.pygame.org/docs/">PyGame Documentation</a><br>
          <a href="https://www.raspberrypi.org/products/raspberry-pi-touch-display/">Raspberry Pi Touch Screen Documentation</a><br>
          <a href="https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/">R-Pi GPIO Document</a><br>

      </div>

    <hr id='appendix'>

    <div class="row">
        <h2>Code Appendix</h2>
        <h3>photodisplayer.py</h3>
        <pre style="width: 80%; height: 500px; overflow: scroll;"><code>
#photodisplayer.py Xinyun Guo xg284 Zhuoheng Li zl764 lab2 10-09-2019
import RPi.GPIO as GPIO
import time
import pygame
from pygame.locals import*
import os
import sys
import glob
from PIL import Image

pygame.init()
pygame.mouse.set_visible(True)

size = width, height = 800, 420
black = 0, 0, 0
white = 255, 255, 255
bottom_line=350

screen = pygame.display.set_mode(size)
font = pygame.font.SysFont('arial',18)
start = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/start.png")
pause = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/stop.jpg")
restart = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/restart.png")
pre = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/previous.png")
next = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/next.png")
speedup = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/2X.png")
speeddown = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/0.5X.png")
scolldown = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/scolldown.png")
quit = pygame.image.load("/home/pi/final_project/insta_project/logo_pics/quit.png")

quit = pygame.transform.scale(quit, (30, 30))
start = pygame.transform.scale(start, (30, 30))
pause = pygame.transform.scale(pause, (30, 30))
restart = pygame.transform.scale(restart, (30, 30))
pre = pygame.transform.scale(pre, (30, 30))
next = pygame.transform.scale(next, (30, 30))
speedup = pygame.transform.scale(speedup, (30, 30))
speeddown = pygame.transform.scale(speeddown, (30, 30))
scolldown = pygame.transform.scale(scolldown, (100, 40))
scolldownrect = scolldown.get_rect()
scolldownrect.x = 0
scolldownrect.y = 380
startrect = start.get_rect()
startrect.x = 50
startrect.y = bottom_line
quitrect = quit.get_rect()
quitrect.x = 700 
quitrect.y = bottom_line
pauserect = pause.get_rect()
pauserect.x = 100
pauserect.y = bottom_line
restartrect = restart.get_rect()
restartrect.x = 100
restartrect.y = bottom_line
prerect = pre.get_rect()
prerect.x = 220
prerect.y = bottom_line
nextrect = next.get_rect()
nextrect.x = 350
nextrect.y = bottom_line
speeddownrect = speeddown.get_rect()
speeddownrect.x = 500
speeddownrect.y = bottom_line
speeduprect = speedup.get_rect()
speeduprect.x = 600
speeduprect.y = bottom_line

def getImages(): 
    valid_formats = [".png", ".PNG", ".jpeg", ".jpg"]
    path = "/home/pi/final_project/insta_project/media/images/"
    image_list = []
    images_added = set()
    for format in valid_formats:
        for imageName in glob.glob(path + "*" + format):
            if imageName not in images_added:
                images_added.add(imageName)
                image = pygame.image.load(imageName)
                image_list.append(image)
    return image_list

# Get all the images under the directory
picture_list = getImages()
picture_rect_list = []
picture_thumbnail = []
picture_rect_thumbnail=[] 
picture_size = [700, 420]

# Creating an array for all the rects of image
for index in range(len(picture_list)) :
    scaled_picture = pygame.transform.scale(picture_list[index], (800, 420))
    picture_list[index] = scaled_picture
    picture_rect_list.append(scaled_picture.get_rect())
    picture_rect_list[index].x=100
    picture_rect_list[index].y=0
for index in range(len(picture_list)) :
    scaled_picture_new = pygame.transform.scale(picture_list[index], (100, 95))
    picture_thumbnail.append(scaled_picture_new)
    picture_rect_thumbnail.append(scaled_picture_new.get_rect())

picture_rect_thumbnail[0].x=0
picture_rect_thumbnail[0].y=0  
picture_rect_thumbnail[1].x=0
picture_rect_thumbnail[1].y=95     
picture_rect_thumbnail[2].x=0
picture_rect_thumbnail[2].y=190    
picture_rect_thumbnail[3].x=0
picture_rect_thumbnail[3].y=285   

start_time = time.time()
codeRunning = True
aniRunning = True
isPause = False
current_picture_index=0
thumbnail_index=0
thumbnail_list=[0,1,2,3]
arry_size=len(picture_list)

temp_time=0
interval=5    
maxspeed=1
minspeed=15

while time.time()-start_time <300 and codeRunning:
    screen.fill(black)
    screen.blit(start,startrect)
    screen.blit(quit,quitrect)
    for event in pygame.event.get():
        if (event.type is MOUSEBUTTONDOWN):
            mouse = pygame.mouse.get_pos()
            if(quitrect.x-15 < mouse[0] < quitrect.x+40 and bottom_line-30 < mouse[1] < bottom_line+30):
                codeRunning = False
            elif (startrect.x-15 < mouse[0] < startrect.x+40 and bottom_line-30 < mouse[1] < bottom_line+30):
                temp_time=time.time()
                while aniRunning:
                    if(time.time()-temp_time >= interval and not isPause ):
                        temp_time=time.time()
                        if(current_picture_index!=arry_size-1):
                            current_picture_index += 1
                        else:
                            current_picture_index=0 
                    screen.fill(black)
                    screen.blit(picture_list[current_picture_index],picture_rect_list[current_picture_index])
                    for index in range(4):
                        screen.blit(picture_thumbnail[thumbnail_list[index]],picture_rect_thumbnail[index])
                    screen.blit(scolldown,scolldownrect)
                    for event in pygame.event.get():
                        if (event.type is MOUSEBUTTONDOWN):
                            mouse = pygame.mouse.get_pos()
                            if quitrect.x-15 < mouse[0] < quitrect.x+40 and bottom_line-30 < mouse[1] < bottom_line+30: 
                                aniRunning = False
                                codeRunning = False
                            if pauserect.x-15 < mouse[0] < pauserect.x+40 and bottom_line-30 < mouse[1] < bottom_line+30:
                                if isPause:
                                    isPause = False
                                    #temp_time=time.time()
                                else:
                                    isPause = True
                                    temp_time=time.time()
                            if prerect.x-15 < mouse[0] < prerect.x+45 and bottom_line-30 < mouse[1] < bottom_line+30:
                                if(current_picture_index != 0):
                                  current_picture_index = current_picture_index - 1
                                else:
                                  current_picture_index = arry_size-1
                            if nextrect.x-15 < mouse[0] < nextrect.x+40 and bottom_line-30 < mouse[1] < bottom_line+30: 
                                if(current_picture_index != arry_size-1):
                                  current_picture_index = current_picture_index + 1
                                else:
                                  current_picture_index = 0
                            if speeduprect.x-15 < mouse[0] < speeduprect.x+40 and bottom_line-30 < mouse[1] < bottom_line+30: 
                                interval=interval/2
                                if interval < maxspeed:
                                    interval=maxspeed
                            if speeddownrect.x-15 < mouse[0] < speeddownrect.x+40 and bottom_line-30 < mouse[1] < bottom_line+30: 
                                interval=interval*2
                                if interval > minspeed:
                                    interval=minspeed
                            #thumbnail function    
                            if 0 < mouse[0] < 95:
                                if 0 < mouse[1] < 100: 
                                    current_picture_index=thumbnail_list[0]
                                if 95 < mouse[1] < 190: 
                                    current_picture_index=thumbnail_list[1]
                                if 190 < mouse[1] < 285: 
                                    current_picture_index=thumbnail_list[2]
                                if 285 < mouse[1] < 380: 
                                    current_picture_index=thumbnail_list[3]
                                if 380 < mouse[1] < 420: 
                                    if thumbnail_index+1 < len(picture_thumbnail):
                                        thumbnail_index=thumbnail_index+1
                                        for index in range (3): 
                                            thumbnail_list[index]=thumbnail_list[index+1]
                                        if thumbnail_index+3 < len(picture_thumbnail):
                                            thumbnail_list[3]=thumbnail_index+3
                                        else:
                                            thumbnail_list[3]=thumbnail_index+3-len(picture_thumbnail)
                                    else:
                                        thumbnail_index=0 
                                        thumbnail_list=[0,1,2,3]
                            
                    if isPause:
                        screen.blit(restart, restartrect)
                    else :
                        screen.blit(pause, pauserect)
                    
                    speed = font.render(str(float(5/interval)),True,white,black)
                    speedrect = speed.get_rect()
                    speedrect.x = 700
                    speedrect.y = bottom_line+30
                    screen.blit(speed,speedrect)
                    screen.blit(pre,prerect)
                    screen.blit(next,nextrect)
                    screen.blit(speedup,speeduprect)
                    screen.blit(speeddown,speeddownrect)
                    screen.blit(quit,quitrect)
                    pygame.display.flip()

        elif(event.type is MOUSEBUTTONUP):
            mouse = pygame.mouse.get_pos()
          
    pygame.display.flip()         
                
        </code></pre>
      </div>

    </div><!-- /.container -->




    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script> -->
  </body>
</html>
